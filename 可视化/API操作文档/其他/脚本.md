# 脚本

<font style="color:rgb(28, 30, 33);">脚本提供了在编辑器操作之外的一种扩展方式，通过脚本可以实现大多数编辑器操作，包括但不限于创建节点、修改节点属性、执行动画等。 脚本仅在页面最终渲染时执行，不会影响编辑器的实时操作。</font>

_<font style="color:rgb(28, 30, 33);">编写脚本可能需要你具有一定的 Jsvascript 编程基础</font>_

<font style="color:rgb(28, 30, 33);">脚本的本质是提供一个函数上下文，通过函数上下文中的 API，可以实现对编辑器的操作。该函数有两个参数，</font>`<font style="color:rgb(28, 30, 33);">Application</font>`<font style="color:rgb(28, 30, 33);"> </font><font style="color:rgb(28, 30, 33);">和</font><font style="color:rgb(28, 30, 33);"> </font>`<font style="color:rgb(28, 30, 33);">HC2D</font>`<font style="color:rgb(28, 30, 33);">。</font>

+ [<font style="color:rgb(28, 30, 33);">Application</font>](https://v2-doc.gkiiot.com/docs/Core/application)<font style="color:rgb(28, 30, 33);"> </font><font style="color:rgb(28, 30, 33);">是编辑器的应用实例，通过它可以对整个应用进行操作。由于脚本是在应用渲染时执行的，</font><font style="color:rgb(28, 30, 33);"> </font>`<font style="color:rgb(28, 30, 33);">Application</font>`<font style="color:rgb(28, 30, 33);"> </font><font style="color:rgb(28, 30, 33);">即表示当前画布应用实例,不需要额外创建。</font>
+ `<font style="color:rgb(28, 30, 33);">HC2D</font>`<font style="color:rgb(28, 30, 33);"> </font><font style="color:rgb(28, 30, 33);">是</font>`<font style="color:rgb(28, 30, 33);">@hc/engine2d</font>`<font style="color:rgb(28, 30, 33);">包导出的所有 API。</font>

## <font style="color:rgb(28, 30, 33);">如何创建一个脚本</font>
<font style="color:rgb(28, 30, 33);">利用前面章节的知识，我们可以创建一个脚本文件，然后在编辑器中导入并执行。</font>

<font style="color:rgb(28, 30, 33);">下面,我们结合在</font>[<font style="color:rgb(28, 30, 33);">基础节点</font>](https://v2-doc.gkiiot.com/docs/Node/basenode#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9)<font style="color:rgb(28, 30, 33);"> </font><font style="color:rgb(28, 30, 33);">和</font><font style="color:rgb(28, 30, 33);"> </font>[<font style="color:rgb(28, 30, 33);">组合块</font>](https://v2-doc.gkiiot.com/docs/Node/collectionrecord#%E7%8A%B6%E6%80%81%E7%BB%84%E5%90%88%E5%9D%97)<font style="color:rgb(28, 30, 33);">中介绍的知识,创建一个脚本。</font>

```javascript
function (app: Application, HC2D: HC2D) {
  // 新建一个矩形节点
  const node1 = app.create({
    type: "Rect",
    x: 1000,
    y: 500,
    width: 200,
    height: 100,
  });
  // 设置节点背景颜色
  node1.Background = "green";

  const node2 = app.create({
    type: "Rect",
    x: 1000,
    y: 500,
    width: 200,
    height: 100,
  });
  node2.Background = "red";

  // 新建一个状态组合块,并将两个节点加入到组合块中
  const group = new HC2D.StateCollectionRecord();
  app.Database.CollectionTable.append(group);
  group.append(node1.ObjectId);
  group.append(node2.ObjectId);

  // 设置状态组合块的状态类型和当前状态
  group.StateType = HC2D.EStateType.Number;
  group.CurrentState = 1;
  group.update();
}
```

<font style="color:rgb(28, 30, 33);">将函数体内的内容复制到编辑器场景的脚本中保存并预览,可以看到,画布中按照当前状态显示了一个红色矩形,当我们点击它时,会在红色矩形和绿色矩形之间切换显示。</font>

## <font style="color:rgb(28, 30, 33);">常见的脚本操作</font>
<font style="color:rgb(28, 30, 33);">以下示例中,</font>`<font style="color:rgb(28, 30, 33);">getNodeById</font>`<font style="color:rgb(28, 30, 33);">传入的参数为节点的标识, 用于获取节点对象。实际操作时,可以选中节点后,通过编辑器右侧面板的【属性】-【基础属性】-【标识】中查看节点的标识。</font>

### <font style="color:rgb(28, 30, 33);">节点属性修改</font>
```javascript
// 基础节点
const node = app.getNodeById(101);

node.Position = { x: 100, y: 100 };
node.Rotation = 45;

// 组合节点的数据绑定修改
const compositeNode = app.getNodeById(102);
const statusValue = compositeNode.DataBindRecord.status.Value; // 当组合节点含有一个名为status的数据绑定时,可以通过DataBindRecord.status.Value来访问和修改值
compositeNode.DataBindRecord.status.Value = false;

// 自定义节点的属性修改
const customNode = app.getNodeById(103);
const data = customNode.getData();
customNode.setData({ bgColor: "green" }); // setData会将传入的对象和原有的数据合并
```

### <font style="color:rgb(28, 30, 33);">节点事件绑定</font>
```javascript
const node = app.getNodeById(101);

// 节点点击事件
node.on("click", () => {
  alert(`${node.Name} 被点击了`);
});

// 节点鼠标移入移出事件
const originColor = node.Background;
node.on("mouseover", () => {
  node.Background = "red";
});
node.on("mouseleave", () => {
  node.Background = originColor;
});
```

### <font style="color:rgb(28, 30, 33);">获取/修改自定义节点的数据</font>
```javascript
const customNode = app.getNodeById(101);
const data = customNode.getData();
customNode.setData({ ...data, bgColor: "green" });
```

### <font style="color:rgb(28, 30, 33);">接口通信</font>
<font style="color:rgb(28, 30, 33);">使用</font>[<font style="color:rgb(28, 30, 33);">fetch API</font>](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)<font style="color:rgb(28, 30, 33);">进行接口通信</font>

```javascript
const button = app.getNodeById(101); // 获取按钮节点
const text = app.getNodeById(102); // 获取文本节点

// 根据具体的需求,决定什么情况下调用接口
button.on("click", () => {
  // url为实际的接口地址
  fetch("https://api.example.com/data")
    .then((response) => response.json())
    .then((data) => {
      // 处理返回的数据
      console.log(data);
      text.Text = data.text;
    });
});
```

### <font style="color:rgb(28, 30, 33);">通过接口数据，修改曲线图数据</font>
<font style="color:rgb(28, 30, 33);">下面的示例基于平台的报表数据接口，实际使用时需要根据实际情况填写接口地址和参数。</font>

```javascript
// 获取曲线图节点
const chartNode = app.getNodeById(102);

// 以某个报表为例，获取报表数据
fetch("/iot/admin/device/ts/prop/interval", {
  method: "POST",
  // 请求头中添加token，用于接口鉴权
  headers: {
    Authorization: JSON.parse(localStorage.getItem("ACCESS-TOKEN"))?.value,
  },
  // 报表的参数信息，具体参数根据实际情况填写
  body: JSON.stringify({
    groupId: 6,
    devId: "NcXBB1u7szlfiQa3w0NZ",
    ignorePage: 1,
    // 起止时间， 这边设为最近7天内的数据
    endTs: Date.now(),
    startTs: Date.now() - 604800 * 1000, // 7天
  }),
}).then(async (data) => {
  const result = await data.json();
  // 成功返回数据
  if (result.code === 0) {
    const list = result?.data?.list;
    // 数据为空时不做任何处理
    if (!list || list.length === 0) return;

    // 修改曲线图的变量数据
    // VariableType表示变量类型，
    // "report"表示类型为报表数据， "device"表示类型为设备数据通常用于websocket实时更新的数据
    chartNode.VariableType = "report";
    // Variables为变量数组，数组中的每个对象表示一个变量，即曲线图的一条线
    // 以温度一项数据为例， wdavg为该报表数据中的一个字段，表示温度的平均值
    chartNode.Variables = [
      /*
       * - name: 变量名称，即曲线图中该条线段的名称
       * - type: 变量类型，"report"表示类型为报表数据， "device"表示类型为设备数据
       * - value: 变量值，为一个数组，数组中的每个对象表示一个数据点
       */
      {
        name: "温度",
        type: "report",
        value: list
          // 过滤掉wdavg为null的无用数据
          .filter((item) => item.wdavg !== null)
          .map((item) => ({
            startAt: item._wstart,
            endAt: item._wend,
            value: item.wdavg,
          })),
      },
    ];
    // 更新曲线图内部数据，触发曲线图的重新渲染
    chartNode.updateData();
  }
});
```



> 更新: 2024-09-30 10:37:43  
> 原文: <https://www.yuque.com/iot-fast/ksh/urtusyz9kg3adale>